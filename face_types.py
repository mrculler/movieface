# Defines some types

import collections

Movie = collections.namedtuple("Movie", ["movie_id", "collection_id", "is_renamed", "filename"])
Collection = collections.namedtuple("Collection", ["collection_id", "display_name", "extension", "path", "drop_path"]) 


# Full definitions are below (generated by specifying "verbose=True" to namedtuple calls)
#
#class Movie(tuple):
#    'Movie(movie_id, collection_id, is_renamed, filename)'
#
#    __slots__ = ()
#
#    _fields = ('movie_id', 'collection_id', 'is_renamed', 'filename')
#
#    def __new__(_cls, movie_id, collection_id, is_renamed, filename):
#        'Create new instance of Movie(movie_id, collection_id, is_renamed, filename)'
#        return _tuple.__new__(_cls, (movie_id, collection_id, is_renamed, filename))
#
#    @classmethod
#    def _make(cls, iterable, new=tuple.__new__, len=len):
#        'Make a new Movie object from a sequence or iterable'
#        result = new(cls, iterable)
#        if len(result) != 4:
#            raise TypeError('Expected 4 arguments, got %d' % len(result))
#        return result
#
#    def __repr__(self):
#        'Return a nicely formatted representation string'
#        return 'Movie(movie_id=%r, collection_id=%r, is_renamed=%r, filename=%r)' % self
#
#    def _asdict(self):
#        'Return a new OrderedDict which maps field names to their values'
#        return OrderedDict(zip(self._fields, self))
#
#    __dict__ = property(_asdict)
#
#    def _replace(_self, **kwds):
#        'Return a new Movie object replacing specified fields with new values'
#        result = _self._make(map(kwds.pop, ('movie_id', 'collection_id', 'is_renamed', 'filename'), _self))
#        if kwds:
#            raise ValueError('Got unexpected field names: %r' % kwds.keys())
#        return result
#
#    def __getnewargs__(self):
#        'Return self as a plain tuple.  Used by copy and pickle.'
#        return tuple(self)
#
#    movie_id = _property(_itemgetter(0), doc='Alias for field number 0')
#
#    collection_id = _property(_itemgetter(1), doc='Alias for field number 1')
#
#    is_renamed = _property(_itemgetter(2), doc='Alias for field number 2')
#
#    filename = _property(_itemgetter(3), doc='Alias for field number 3')
#
#
#class Collection(tuple):
#    'Collection(collection_id, display_name, extension, path, drop_path)'
#
#    __slots__ = ()
#
#    _fields = ('collection_id', 'display_name', 'extension', 'path', 'drop_path')
#
#    def __new__(_cls, collection_id, display_name, extension, path, drop_path):
#        'Create new instance of Collection(collection_id, display_name, extension, path, drop_path)'
#        return _tuple.__new__(_cls, (collection_id, display_name, extension, path, drop_path))
#
#    @classmethod
#    def _make(cls, iterable, new=tuple.__new__, len=len):
#        'Make a new Collection object from a sequence or iterable'
#        result = new(cls, iterable)
#        if len(result) != 5:
#            raise TypeError('Expected 5 arguments, got %d' % len(result))
#        return result
#
#    def __repr__(self):
#        'Return a nicely formatted representation string'
#        return 'Collection(collection_id=%r, display_name=%r, extension=%r, path=%r, drop_path=%r)' % self
#
#    def _asdict(self):
#        'Return a new OrderedDict which maps field names to their values'
#        return OrderedDict(zip(self._fields, self))
#
#    __dict__ = property(_asdict)
#
#    def _replace(_self, **kwds):
#        'Return a new Collection object replacing specified fields with new values'
#        result = _self._make(map(kwds.pop, ('collection_id', 'display_name', 'extension', 'path', 'drop_path'), _self))
#        if kwds:
#            raise ValueError('Got unexpected field names: %r' % kwds.keys())
#        return result
#
#    def __getnewargs__(self):
#        'Return self as a plain tuple.  Used by copy and pickle.'
#        return tuple(self)
#
#    collection_id = _property(_itemgetter(0), doc='Alias for field number 0')
#
#    display_name = _property(_itemgetter(1), doc='Alias for field number 1')
#
#    extension = _property(_itemgetter(2), doc='Alias for field number 2')
#
#    path = _property(_itemgetter(3), doc='Alias for field number 3')
#
#    drop_path = _property(_itemgetter(4), doc='Alias for field number 4')
